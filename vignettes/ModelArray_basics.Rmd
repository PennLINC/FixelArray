---
title: "ModelArray: Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ModelArray_basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(ModelArray)
library(testthat)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
Here we will use some example data to show you the basic use of `ModelArray`.

# Concepts and Goals
## Goals
The general goal is to provide a generalizable R package for statistical analysis for different modalities of data, such as voxel-wise, vertex-wise, or fixel-wise data. The features include:

* Low memory requirement, and not scale up with number of subjects
* Providing statistical models such linear regression model and generalized additive model (GAM), which are useful especially for modeling age effects in development and aging
* Easy and straightforward to use with just several lines of R codes


## Elements
In this package, "element" is a general name for one point of data; it could be voxel in 3D images, vertex in surface data, or fixel in fixel-based analysis. There should be scalar value associated with each element. And with some demographics or other phenotype data, we can model the scalar value with independent variables and covariates. We treat each element equally.



# Quick start: fixel-wise statistical analysis
## Load data using `ModelArray()`
We provide example .h5 data in "inst/extdata". Example data is fixel-wise data generated by ConFixel python package. 
```{r}
# file of example .h5, fixel-wise data
h5_path <- system.file("extdata", "n50_fixels.h5", package = "ModelArray")
modelarray <- ModelArray(h5_path, 
                               scalar_types = c("FD"))  # if there is more than one metric, you can do: c("FD", "FDC")
modelarray # check what's in it    
```
This shows that there are 50 subjects, with scalars of FD in this the `modelarray` you loaded.


## accessors of ModelArray
To access ModelArray's slots:
```{r}
scalars(modelarray)[["FD"]]   # FD data
subjects(modelarray)[["FD"]]  # subject list for FD data
```

## preparation for statistical analysis
To perform statistical analysis, please provide a data frame with subjects' demographic or phenotype data you are interested in:
```{r}
csv_path <- system.file("extdata", "n50_cohort.csv", package = "ModelArray")
phenotypes <- read.csv(csv_path)
colname_subject_id <- "subject_id"   # the column name of subject IDs in phenotypes data.frame. This will be used for sanity check vs that in .h5 file
head(phenotypes)
```
## linear regression
Now, let's perform linear regression metric FD (y) over subject's age, using `ModelArray.lm()`:
```{r}
formula <- FD ~ age
mylm_fullOutputs <- ModelArray.lm(formula, modelarray, phenotypes, "FD",  # dependent variable
                      element.subset = 1:100,  # let's check out first 100 fixels
                      colname.subjid = colname_subject_id,   # subject sanity check will be performed: subject id in phenotypes data frame vs that in .h5 scalar data
                      full.outputs = TRUE, # let's first view all statistics
                      )
head(mylm_fullOutputs)
```
If all statistics are too many for you, try out default list of statistics:
```{r}
mylm_default <- ModelArray.lm(formula, modelarray, phenotypes, "FD", element.subset = 1:100,  colname.subjid = colname_subject_id, 
                      n_cores = 4,  # running on 4 CPU cores for speeding up
                      )
head(mylm_default)
```

You may be specifically interested in several statistics:
```{r}
mylm <- ModelArray.lm(formula, modelarray, phenotypes, "FD", element.subset = 1:100,  colname.subjid = colname_subject_id, 
                      var.terms = c("estimate", "p.value"), # statistics for terms such as intercept, age
                      var.model = c("r.squared", "p.value", "AIC"),    # statistics for the model
                      correct.p.value.terms = c("fdr","bonferroni"),   # p value corrections for terms
                      correct.p.value.model = "fdr",  # p value corrections for model
                      n_cores = 4,
)
head(mylm)
```

To run across all fixels, simply use default setting that `element.subset = NULL`.

## GAM - Generalized additive model
Modelling age effect with GAM is often useful for developing population because of GAM's flexibility. Running `ModelArray.gam()` is similar to `ModelArray.lm()`:
```{r}
formula <- FD ~ s(age, k=4, fx=TRUE) + sex  # we add sex as a covariate
mygam <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:100,
                          colname.subjid = colname_subject_id,
                        n_cores = 4, pbar = TRUE)
head(mygam)
```
You can also set `full.outputs=TRUE` to request all statistics (except p.value corrections or effect size - see below for more). 

Or you can specify the specific statistic terms you are interested in by assigning the values of `var.smoothTerms`, `var.parametricTerms`, and `var.model`:
```{r}
mygam_specific <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:100,
                          colname.subjid = colname_subject_id,
                          var.smoothTerms = c("p.value"),  # this is for smooth term, e.g. s(age) in our case
                          var.parametricTerms = c("estimate"),   # this is for parametric term, e.g. sex in our case
                          var.model = c("adj.r.squared", "dev.expl"),  # this is for the model
                        n_cores = 4, pbar = TRUE)
head(mygam_specific)
```

In addition, you can also request calculating effect size for a specific term, usually a smooth term. Effect size of a term is defined as  difference between adjusted R squared of full model (formula requested) and that of reduced model (formula without the requested term).
```{r}
mygam_effectSize <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:100,
                          colname.subjid = colname_subject_id,
                          var.smoothTerms = c(), var.parametricTerms = c(), var.model = c("adj.r.squared"),  
                          eff.size.term.index = c(1),   # requesting effect size for the 1st term on right hand side of formula, i.e. s(age) in this case
                        n_cores = 4, pbar = TRUE)

head(mygam_effectSize)
```

## write the results 
Finally, you can write the results (data frame of statistics) back into the .h5 file. 
```{r}
# it's not necessary to make a copy of original .h5 file as we are doing here - you can write the results into original one. Here we make a copy only not to overwrite the example data we provide in the package.
h5_output_path <- gsub(".h5","_output.h5",h5_path)
file.copy(from=h5_path, to=h5_output_path, overwrite = TRUE, copy.mode = TRUE, copy.date = TRUE)
modelarray_output <- ModelArray(filepath = h5_output_path, scalar_types = "FD")

# write linear model results:
writeResults(h5_output_path, df.output = mylm,  # the results data.frame you got
             analysis_name="result_lm", # give the results a name - you will use this name again when converting back to .mif in ConFixel
             overwrite=TRUE)  # if there is an existing result with the same name in .h5, overwrite it

# write GAM results:
writeResults(h5_output_path, df.output = mygam_specific,  
             analysis_name="result_gam", 
             overwrite=TRUE)

```


You can reload the .h5 file and check the results:
```{r}
modelarray_new <- ModelArray(filepath = h5_output_path, scalar_types = "FD",
                             analysis_names = c("result_lm", "result_gam"))   # you can load more than one result at a time
```

To access the results, simply use `results()`:
```{r}
results(modelarray_new)[["result_lm"]]$results_matrix
results(modelarray_new)[["result_gam"]]$results_matrix
```


```{r, include = FALSE}
file.remove(h5_output_path)

```